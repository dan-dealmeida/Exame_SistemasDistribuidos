RELATÓRIO DO PROJETO - QUEBRA DE SENHAS N CIFRAS

Este arquivo contém os links e as análises comparativas do projeto.

=======================================================
LINKS
=======================================================

- Link para o repositório no GitHub: https://github.com/dan-dealmeida/Exame_SistemasDistribuidos
- Link para o vídeo de apresentação: 

=======================================================
ANÁLISE DE TEMPOS E ESCALABILIDADE
=======================================================

Para o teste de 6 dígitos numéricos (1.000.000 de combinações):
| Abordagem             | Tempo de Execução (6 dígitos numéricos) | 
|-----------------------|-----------------------------------------|
| Sequencial            | 0.0086s                                 | 
| Paralela (4 Threads)  | 0.1616s                                 |
| Distribuída (2 Clientes)| 0.0481s                               |       

Para o teste de 8 dígitos numéricos (100.000.000 de combinações):
| Abordagem             | Tempo de Execução (8 dígitos numéricos) |
|-----------------------|-----------------------------------------|
| Sequencial            | 1.0440s                                 |
| Paralela (4 Threads)  | 17.3309s                                | 
| Distribuída (2 Clientes)| 5.4292s                               | 

Para o teste de 9 dígitos numéricos (1.000.000.000 (1 bilhão) de combinações):
| Abordagem             | Tempo de Execução (9 dígitos numéricos) |
|-----------------------|-----------------------------------------|
| Sequencial            | 10.4465s                                 |
| Paralela (4 Threads)  | 184.9746s                                | 
| Distribuída (2 Clientes)| 56.5355s                               | 
Obs: O meu script usa o módulo threading do Python. O interpretador padrão do Python (CPython) possui algo chamado Global Interpreter Lock (GIL). Em termos simples, o GIL é um mecanismo que permite que apenas uma thread execute código Python por vez dentro de um único processo. Por isso ao aumentar o numero de threads eu noto que fica mais lento.

Para o teste de Senha Alfanumérica (minúsculas) de 6 Dígitos:Z
| Abordagem             | Tempo de Execução em segundos           |
|-----------------------|-----------------------------------------|
| Sequencial            | 4.6678                                  |
| Paralela (4 Threads)  | 139.6167                                | 
| Distribuída (2 Clientes)| 14.0052                               | 

Análise de Escalabilidade:
=======================================================
DESAFIOS ENCONTRADOS E MELHORIAS PROPOSTAS
=======================================================

Desafios:
1.  **Sincronização em Threads (Paralelo):** Garantir que, assim que uma thread encontrasse a senha, todas as outras parassem de trabalhar foi um desafio. A solução foi usar um `threading.Event`, que é uma forma eficiente de sinalizar um evento entre threads sem a necessidade de locks complexos.

2.  **Comunicação de Rede (Distribuído):** A comunicação via sockets exige um protocolo bem definido (como enviar os dados da tarefa, como reportar o sucesso/falha). A sobrecarga (overhead) da comunicação de rede pode tornar a solução distribuída mais lenta que a paralela para problemas pequenos, mas ela se destaca em problemas massivos.

3.  **Divisão de Carga:** Calcular os intervalos corretos para cada thread/cliente de forma que nenhum trabalho seja duplicado ou omitido foi crucial. A função `math.ceil` ajudou a garantir uma distribuição justa, mesmo quando o número de combinações não era perfeitamente divisível.

Melhorias Propostas:
1.  **Frameworks de Alto Nível:** Em vez de sockets puros, poderíamos usar RMI (Remote Method Invocation) com bibliotecas como `Pyro5` em Python. Isso abstrairia a comunicação de rede, tornando o código mais limpo e focado na lógica de negócio, embora pudesse adicionar uma pequena camada de complexidade na configuração inicial.

2.  **Balanceamento de Carga Dinâmico:** Atualmente, o trabalho é dividido estaticamente no início. Uma melhoria seria o servidor distribuir "pedaços" de trabalho sob demanda. Se um cliente termina sua tarefa rapidamente (por ter um hardware melhor), ele poderia pedir mais trabalho ao servidor. Isso otimizaria o uso de recursos heterogêneos.

3.  **Tolerância a Falhas:** A solução distribuída atual é sensível a falhas. Se um cliente desconectar, sua parte do trabalho se perde. Um sistema mais robusto poderia reatribuir o trabalho de um cliente que falhou para outro que esteja ativo.
